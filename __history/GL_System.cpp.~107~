//---------------------------------------------------------------------------

#pragma hdrstop

#include "GL_System.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#include <list>
#include "GL_Place.h"
#include "GL_Port.h"
#include "GL_Sensor.h"

#include <System.SysUtils.hpp>
//---------------------------------------------------------------------------

TGLSystem::TGLSystem()
{
   name = L"GorizontLab Monitoring System";
   mark = L"...";
   node = NULL;
}

TGLSystem::TGLSystem(TTreeView* t, TXMLDocument* xmlDoc)
{
   name = L"GorizontLab Monitoring System";
   mark = L"...";
   tree = t;
   node = this->tree->Items->Add(NULL, this->name);

   SysConfMgr = new TSysConfMgr();
   SysConfMgr->SetXMLDoc(xmlDoc);
   DBMgr = new TDataBaseMgr();
   BBFMgr = new TBBFMgr();

   sens_uid_max = 1;
}

TGLSystem::~TGLSystem()
{

}

TGLPlace* TGLSystem::add_place(WideString nm)
{
	int nmb = place_list.count() + 1;
	pl = new TGLPlace(nm, NULL, place_list.count() + 1);

	//the place shall have unique name & number in the list
	if (place_list.add(pl) != 0)
	{
		delete pl;
		pl = NULL;
		//return -1;  //fail to add the place
	}
	else
	{
	//  create the place title in the browser & create tree node
		WideString ss;
		ss.printf(L"%d [", nmb);
		ss = ss+nm;
		ss = ss+L"]";
		TTreeNode* ndd = tree->Items->AddChild(node, ss); ndd->ImageIndex = 1; ndd->SelectedIndex = 1;

		pl->SetTree(tree);
		pl->SetNode(ndd);

		////// !!!

		//pl->add_port(L"COM_1");
		//pl->add_port(L"COM_2");
		//pl->add_port(L"COM_3");

		node->Expand(true);
		//return 0;
	}

	return pl;
}

TTreeNode* TGLSystem::get_node(void)
{
	return node;
}

void TGLSystem::View(BYTE state)
{
	node->ImageIndex = 0;
	node->SelectedIndex = 0;  node->SelectedIndex = 0;
}

/*
TGLPlace* TGLSystem::GetPlace(int n)
{
	TGLPlace* pl = NULL;

	pl = place_list.find(n);

	return pl;
}
*/

TObject* TGLSystem::GetBrowserElement(TTreeNode* nd, int* type)
{
	*type = OBJ_TYPE_NONE;
	TObject* res = NULL;

	cur_pl = NULL;
	cur_pr = NULL;
	cur_sn = NULL;

	if (nd == this->node)
	{
		*type = OBJ_TYPE_SYST;
		return  (TObject*)this;
	}
	else if ((res = (TObject*)place_list.find(nd)) != NULL)
	{
		*type = OBJ_TYPE_PLCE;
		cur_pl = (TGLPlace*)res;
		return res;
	}
	else
	{
		TGLPlace* pl = NULL;
		TGLPort* pr = NULL;
		TGLSensor* sn = NULL;

		for (auto itpl : place_list.m_list)
		{
			if ((res = (TObject*)itpl->port_list.find(nd)) != NULL)
			{
				*type = OBJ_TYPE_PORT;

				cur_pl = itpl;
				cur_pr = (TGLPort*) res;

				return res;
			}

			for (auto itpr : itpl->port_list.m_list)
			{
				if ((res = (TObject*)itpr->sensor_list.find(nd)) != NULL)
				{
					*type = OBJ_TYPE_SNSR;

					cur_pl = (TGLPlace*) itpl;
					cur_pr = (TGLPort*) itpr;
					cur_sn = (TGLSensor*) res;

					return res;
				}
			}

		}
	}

	return res;
}

void TGLSystem::ProcBrowserСlick(TTreeNode* nd, int* tp)
{
	int type = OBJ_TYPE_NONE;
	TObject* obj = NULL;
	WideString ss;

	cur_pl = NULL;
	cur_pr = NULL;
	cur_sn = NULL;
	 
	 obj = GetBrowserElement(nd, &type);
	 {

		switch (type)
		{
			case OBJ_TYPE_SYST:

				ss.printf(L"СИСТЕМА: %s", this->name.c_bstr());

			break;

			case OBJ_TYPE_PLCE:

				cur_pl = (TGLPlace*)obj;
				ss.printf(L"МЕСТО: %d %s", cur_pl->num, cur_pl->name.c_bstr());

			break;

			case OBJ_TYPE_PORT:

				cur_pr = (TGLPort*)obj;
				ss.printf(L"ПОРТ: %d.%d %s", cur_pr->plnum, cur_pr->num, cur_pr->name.c_bstr());

			break;

			case OBJ_TYPE_SNSR:

				cur_sn = (TGLSensor*)obj;
				ss.printf(L"ДАТЧИК: %d.%d.%d %s", cur_sn->plnum, cur_sn->prnum, cur_sn->num, cur_sn->name.c_bstr());

			break;

			default:;

		}

	 }

	*tp =  type;
	//ShowMessage(ss);
    g_ws_msg = ss;

}

TGLPort* TGLSystem::add_port(WideString nm)
{
   if (cur_pl != NULL)
   {
	   return cur_pl->add_port(nm);
   }

   return NULL;
}

TGLSensor* TGLSystem::add_sensor(WideString nm, int uid)
{
	TGLSensor* sn = NULL;

   if ((cur_pr != NULL) &&  (cur_pl != NULL))
   {
	   sn = cur_pr->add_sensor(nm, cur_pl->num, 0);
	   if (sn)
	   {
		   //sens_uid_max++;
		   return sn;
       }
   }

   return NULL;
}

int TGLSystem::SaveConf(void)
{
   TXMLDocument* XMLDoc = SysConfMgr->GetXMLDoc();

   if (XMLDoc != nullptr)
   {
		XMLDoc->ChildNodes->Clear();
   }

   XMLDoc->Options = XMLDoc->Options << doNodeAutoIndent;
   XMLDoc->Version = "1.0";
   XMLDoc->Encoding = "UTF-16"; // Устанавливаем кодировку на UTF-16

   _di_IXMLNode RootNode = XMLDoc->AddChild("system");
   RootNode->Attributes["name"] = name.c_bstr(); // Устанавливаем атрибут

   int plid = 0;
   int prid = 0;
   int snid = 0;

   WideString sid ("");
   WideString spar ("");

   _di_IXMLNode PlacesListNode = RootNode->AddChild("objects_list");


	for (auto itpl : place_list.m_list)
	{
		//_di_IXMLNode ObjectNode = RootNode->AddChild("object");

		_di_IXMLNode ObjectNode = PlacesListNode->AddChild("object");

		sid.printf(L"%d", ++plid);
		ObjectNode->Attributes["ID"] = sid;
		ObjectNode->AddChild("name")->Text = itpl->name;

		prid = 0;

		_di_IXMLNode PortsListNode = ObjectNode->AddChild("ports_list");

		for (auto itpr : itpl->port_list.m_list)
		{
			//_di_IXMLNode PortNode = ObjectNode->AddChild("port");

			_di_IXMLNode PortNode = PortsListNode->AddChild("port");

			sid.printf(L"%d.%d", plid, ++prid);

			PortNode->Attributes["ID"] = sid;
			PortNode->AddChild("name")->Text = itpr->name;

			spar.printf(L"%d", itpr->get_sys_port_num());
			PortNode->AddChild("sys_port_num")->Text = spar;

			spar.printf(L"%d", itpr->get_baud());
			PortNode->AddChild("baud_rate")->Text = spar;

			spar.printf(L"%d", itpr->get_on());
			PortNode->AddChild("on")->Text = spar;

			PortNode->AddChild("mark")->Text = cur_pr->get_mark();

			spar.printf(L"%d", itpr->get_type());
			PortNode->AddChild("type")->Text = spar;

			snid = 0;

			_di_IXMLNode SensorsListNode = PortNode->AddChild("sensors_list");

			for (auto itsn : itpr->sensor_list.m_list)
			{
				//_di_IXMLNode SensorNode = PortNode->AddChild("sensor");

				_di_IXMLNode SensorNode = SensorsListNode->AddChild("sensor");

				sid.printf(L"%d.%d.%d", plid, prid, ++snid);
				SensorNode->Attributes["ID"] = sid;
				SensorNode->AddChild("name")->Text = itsn->GetName();
				WideString s("");

				s.printf(L"%03d", itsn->get_uid());
				SensorNode->AddChild("uid")->Text = s;
			}
		}

	}

   TCHAR* path = SysConfMgr->GetXMLDocPath();
   TCHAR pathb [1024];
   wcscpy(pathb, SysConfMgr->GetXMLDocPath());
   wcscat(pathb, L".back");

   ::DeleteFile(pathb);
   ::CopyFile(path, pathb, true);
   ::DeleteFile(path);

   Sleep(100);

   XMLDoc->SaveToFile(path);

   SysConfMgr->SaveCurSysName();

   console(L"Система", L"Сохранена текущая конфигурация");

   return 0;
}

int TGLSystem::LoadConf(void)
{
   tree->Visible = false;

   TXMLDocument* XMLDoc = SysConfMgr->GetXMLDoc();

   int plid = 0;
   int prid = 0;
   int snid = 0;

   WideString sid ("");

   cur_pl = NULL;
   cur_pr = NULL;
   cur_sn = NULL;

   m_port_proc_thread_list.clear();

   try
   {
	  TCHAR* path = SysConfMgr->GetXMLDocPath();
	  _di_IXMLDocument xmlDoc;

	try
	{
			xmlDoc = LoadXMLDocument(path);
	}
	catch (...)
	{
		 ShowMessage(L"Конфигурация не найдена и будет создана заново!");
		 return -1;
	}

	 _di_IXMLNode rootNode = xmlDoc->DocumentElement;

	 //no any tags for systyem level

	 _di_IXMLNode ObjectsListNode = rootNode->ChildNodes->FindNode("objects_list");

	 if (ObjectsListNode)
	 {
		for (int i = 0; i < ObjectsListNode->ChildNodes->Count; i++)
		{

			_di_IXMLNode PlaceNode = ObjectsListNode->ChildNodes->Nodes[i];
			_di_IXMLNode PlaceNameNode = PlaceNode->ChildNodes->FindNode("name");

			if (PlaceNameNode)
			{
				cur_pl = add_place (PlaceNameNode->Text);
			}
			else
			{
				//std::cout << "Тег name не найден в узле objectNode." << std::endl;
			}

			//here load other place params

			_di_IXMLNode PortsListNode = PlaceNode->ChildNodes->FindNode("ports_list");

			for (int i = 0; i < PortsListNode->ChildNodes->Count; i++)
			{
				_di_IXMLNode PortNode = PortsListNode->ChildNodes->Nodes[i];
				_di_IXMLNode PortNameNode = PortNode->ChildNodes->FindNode("name");

				if (PortNode)
				{
					cur_pr = add_port (PortNameNode->Text);

					TPortProcThread* ppt = new TPortProcThread(true, cur_pr);
					m_port_proc_thread_list.push_back(ppt);

					Sleep(1);
				}
				else
				{
				//std::cout << "Тег name не найден в узле objectNode." << std::endl;
				}

				_di_IXMLNode PorSysNumNode = PortNode->ChildNodes->FindNode("sys_port_num");
				if ( PorSysNumNode)
				{
					cur_pr->set_sys_port_num(PorSysNumNode->Text.ToInt());
				}

				_di_IXMLNode PorBaudNode = PortNode->ChildNodes->FindNode("baud_rate");
				if ( PorBaudNode)
				{
					cur_pr->set_baud((DWORD)PorBaudNode->Text.ToInt());
				}

				_di_IXMLNode PorOnNode = PortNode->ChildNodes->FindNode("on");
				if ( PorOnNode)
				{
					cur_pr->set_on(PorOnNode->Text.ToInt());
				}

				_di_IXMLNode PorMarkNode = PortNode->ChildNodes->FindNode("mark");
				if ( PorMarkNode)
				{
					cur_pr->set_mark(PorMarkNode->Text.c_str());
				}

				_di_IXMLNode PorTypeNode = PortNode->ChildNodes->FindNode("type");
				if ( PorTypeNode)
				{
					cur_pr->set_type(PorTypeNode->Text.ToInt());
				}

				//load other port attr here

				_di_IXMLNode SensorsListNode = PortNode->ChildNodes->FindNode("sensors_list");

				for (int i = 0; i < SensorsListNode->ChildNodes->Count; i++)
				{
					_di_IXMLNode SensorNode = SensorsListNode->ChildNodes->Nodes[i];
					_di_IXMLNode SensorNameNode = SensorNode->ChildNodes->FindNode("name");

					if (SensorNameNode)
					{
						cur_sn = add_sensor (SensorNameNode->Text, 0);
					}
					else
					{

					}

					_di_IXMLNode uidNode = SensorNode->ChildNodes->FindNode("uid");

					if (uidNode)
					{
						cur_sn->set_uid (StrToIntDef(uidNode->Text, 0));
						if (sens_uid_max <= cur_sn->get_uid())
						{
							sens_uid_max = cur_sn->get_uid() + 1;
						}
					}
					else
					{

					}

				}


			}
		}


		Sleep(1);
	 }


	 tree->Visible = true;

	 ReDraw();


	 return 0;//

	 int tmp = rootNode->ChildNodes->Count;

	 for (int i = 0; i < rootNode->ChildNodes->Count; i++)
	 {
		_di_IXMLNode objectNode = rootNode->ChildNodes->Nodes[i];
		_di_IXMLNode nameNode = objectNode->ChildNodes->FindNode("name");
		if (nameNode)
		{
			cur_pl = add_place (nameNode->Text);
		}
		else
		{
			//std::cout << "Тег name не найден в узле objectNode." << std::endl;
		}

		tmp = objectNode->ChildNodes->Count;

		for (int i = 0; i < objectNode->ChildNodes->Count; i++)
		{
			_di_IXMLNode portNode = objectNode->ChildNodes->Nodes[i];
			_di_IXMLNode nameNode = portNode->ChildNodes->FindNode("name");
			if (nameNode)
			{
				cur_pr = add_port (nameNode->Text);

				TPortProcThread* ppt = new TPortProcThread(true, cur_pr);
				m_port_proc_thread_list.push_back(ppt);

				Sleep(1);
			}
			else
			{
			//std::cout << "Тег name не найден в узле objectNode." << std::endl;
			}

			tmp = portNode->ChildNodes->Count;

			for (int i = 0; i < portNode->ChildNodes->Count; i++)
			{
				TGLSensor* sn = NULL;

				_di_IXMLNode sensorNode = portNode->ChildNodes->Nodes[i];
				_di_IXMLNode nameNode = sensorNode->ChildNodes->FindNode("name");
				_di_IXMLNode uidNode = sensorNode->ChildNodes->FindNode("uid");

				if (sensorNode)
				{
                   for (int i = 0; i < portNode->ChildNodes->Count; i++)
				   {

                   }
				}
				else
				{

                }

				if (nameNode)
				{
					sn = add_sensor (nameNode->Text, 0);
				}
				else
				{

				}

				if (uidNode)
				{
					sn->set_uid (StrToIntDef(uidNode->Text, 0));
					if (sens_uid_max <= sn->get_uid())
					{
						sens_uid_max = sn->get_uid() + 1;
					}
				}
				else
				{

				}
				//_di_IXMLNode baudNode = sensorNode->ChildNodes->FindNode("baud");
				//if (baudNode)
				//{
				//	sn->SetBaud(StrToIntDef(baudNode->Text, 0));
				//}
				//else
				//{
				//std::cout << "Тег name не найден в узле objectNode." << std::endl;
				//}

					   /*
				//try
				//{
					_di_IXMLNode uidNode = sensorNode->ChildNodes->FindNode("uid");
					if (uidNode)
					{
						sn->set_uid(StrToIntDef(uidNode->Text, 0));

						if (sn->get_uid() > sens_uid_max) sens_uid_max = sn->get_uid() + 1;
					}
					else
					{
						sn->set_uid(0);
					//std::cout << "Тег name не найден в узле objectNode." << std::endl;
					}   */
				//}
				//catch (...)
				//{

				//}
			}

		}
	 }

	 //bool rflag = false;

	 for (auto ipl: place_list.m_list)
	 {
		for (auto ipr: ipl->port_list.m_list)
		{
			for (auto isn: ipr->sensor_list.m_list)
			{
			   if (true)
			   {
				  if (isn->get_uid() == 0)
				  {
					 isn->set_uid(sens_uid_max++);
				  }
			   }
			}
		}
	 }

	 //if (rflag)

	 tree->Visible = true;

	 ReDraw();

	 Sleep(1);
   }
   catch(...)
   {
	   //ShowMessage(L"Конфигурация не найдена и будет создана заново!");
   }



   return 0;
}

TGLSensor* TGLSystem::GetCurSn(void)
{
	return cur_sn;
}

int TGLSystem::ReDraw(void)
{
	 for (auto ipl: place_list.m_list)
	 {
		for (auto ipr: ipl->port_list.m_list)
		{
			for (auto isn: ipr->sensor_list.m_list)
			{
			   if (true)
			   {
				  if (isn->get_uid() == 0)
				  {
					 isn->set_uid(sens_uid_max++);
				  }
			   }
			}
		}
	 }

	tree->Visible = false;

	tree->Items->Clear();

	node = this->tree->Items->Add(NULL, this->name);

	int plnum = 0;
	int prnum = 0;
	int snnum = 0;

	for (auto itpl : place_list.m_list)
	{
		itpl->ReDraw(node, ++plnum);

		prnum = 0;

		for (auto itpr : itpl->port_list.m_list)
		{
			itpr->ReDraw(itpl->GetNode(), plnum, ++prnum);

			snnum = 0;

			for (auto itsn : itpr->sensor_list.m_list)
			{
				itsn->ReDraw(itpr->GetNode(), plnum, prnum, ++snnum);
			}


		}
	}

     tree->Visible = true;

	return 0;
}

int TGLSystem::delete_sensor(void)
{

	cur_pr->sensor_list.remove(cur_sn->name);

	//delete cur_sn;

	ReDraw();

	return 0;
}

int TGLSystem::delete_port(void)
{

	cur_pl->port_list.remove(cur_pr->name);

	//delete cur_pr;

	ReDraw();

	return 0;
}

int TGLSystem::delete_place(void)
{

	place_list.remove(cur_pl->name);

	//for (auto itpr : cur_pl->port_list.m_list)
	//{
	//	delete itpr;
	//}

	//delete cur_pl;

	ReDraw();

	return 0;
}

TCHAR* TGLSystem::GetConfPath(void)
{
	return SysConfMgr->GetXMLDocPath();
}

int TGLSystem::CreateConf(TSaveDialog* dlg)
{
	if (SysConfMgr->CreateConf(dlg) != 0) return -1;

	Clear();
	SaveConf();
	LoadConf();
	//ReDraw();

	WideString s = L"Создана конфигурация ";

	s = s + SysConfMgr->GetCurConfPath();

	console(L"Система", s);

	return 0;
}

int TGLSystem::OpenConf(TOpenDialog* dlg)
{
	if (SysConfMgr->OpenConf(dlg) != 0) return -1;

	Clear();
	LoadConf();
	//ReDraw();

	WideString s = L"Загружена конфигурация ";

	s = s + SysConfMgr->GetCurConfPath();

	console(L"Система", s);

   return 0;
}

int TGLSystem::Clear(void)
{

   place_list.m_list.clear();

   tree->Items->Clear();
   node = this->tree->Items->Add(NULL, this->name);

   return 0;
}

int TGLSystem::SaveConf(TSaveDialog* dlg)
{
	if (SysConfMgr->SaveConf(dlg) != 0) return -1;

	Clear();
	LoadConf();
	//ReDraw();
	WideString s = L"Сохранена конфигурация ";

	s = s + SysConfMgr->GetCurConfPath();

	console(L"Система", s);

   return 0;
}

void TGLSystem::run_engine_start ()
{
	for (auto ppt : m_port_proc_thread_list)
	{
	   ppt->start();
	}
}

void TGLSystem::run_engine_suspend ()
{
	for (auto ppt : m_port_proc_thread_list)
	{
	   ppt->suspend();
	}
}

void TGLSystem::run_engine_resume ()
{
	for (auto ppt : m_port_proc_thread_list)
	{
	   ppt->resume();
	}
}

void TGLSystem::set_console(TListBox* list)
{
	list_console = list;
}

void TGLSystem::console(WideString  obj, WideString  msg)
{
   WideString s = FormatDateTime(L"[dd-mm-yyyy hh:nn:ss] ", Now());
   s = s + L"[" + obj + L"] ";
   s = s + msg;

   list_console->Items->Add(s);

   FILE* f = _wfopen(SysConfMgr->GetLogFilePath(), L"rb");

   if (f == NULL)
   {
		BYTE sgn [] = {0xff, 0xfe};

		fclose(f);
		FILE* f = _wfopen(SysConfMgr->GetLogFilePath(), L"wb");
		fwrite(sgn, 2, 1, f);
		fclose(f);

   }

   f = _wfopen(SysConfMgr->GetLogFilePath(), L"ab");

   s = s + L"\r\n";

   fwrite(s.c_bstr(), wcslen(s.c_bstr())*2, 1, f);

   fclose(f);
}

int TGLSystem::open_DB(void)
{
   if (DBMgr->is_base_open() == false)
   {
		return DBMgr->open_base(SysConfMgr->GetCurBasePath());
   }

   return 0;
}

double x = 23.456;
double y = 569.567;

#pragma synchronous=OFF
#pragma journal_mode=WAL

int TGLSystem::store_sensor_data(TDateTime t)
{

	DBMgr->BEGIN_TRANSACTION();

	for (auto itpl : place_list.m_list)
	{
		for (auto itpr : itpl->port_list.m_list)
		{
			for (auto itsn : itpr->sensor_list.m_list)
			{
               itsn->subst(x,y);

			   DBMgr->save_sensor_data_s(t, itsn);

			   x += 1.23; y += 4.56;
			}
		}
	}

	DBMgr->END_TRANSACTION();
}

std::list<dt_sensor_data_record_s> TGLSystem::read_sensor_data_s(TGLSensor* sn, TDateTime t1, TDateTime t2)
{
   return DBMgr->read_sensor_data_s(sn, t1, t2);
}

TGLSensor* TGLSystem::get_cur_sensor(void)
{
	return cur_sn;
}

int TGLSystem::get_sens_uid_max(void)
{
	return sens_uid_max;
}

int TGLSystem::bbf_save_sensor_data_s(TDateTime t, TGLSensor* sn)
{

	BBFMgr->save_sensor_data_s(SysConfMgr->GetCurBasePath(), t, sn);

	return 0;
}

int TGLSystem::bbf_store_sensor_data(TDateTime t)
{

	for (auto itpl : place_list.m_list)
	{
		for (auto itpr : itpl->port_list.m_list)
		{
			for (auto itsn : itpr->sensor_list.m_list)
			{
               itsn->subst(x,y);

			   bbf_save_sensor_data_s(t, itsn);

			   x += 1.23; y += 4.56;
			}
		}
	}


}

std::list<dt_sensor_data_record_s> TGLSystem::bbf_read_sensor_data_s(TGLSensor* sn, TDateTime t1, TDateTime t2)
{
   return BBFMgr->read_sensor_data_s(SysConfMgr->GetCurBasePath(), sn, t1, t2);
}

TGLPort* TGLSystem::GetCurPr(void)
{
	return cur_pr;
}
