//---------------------------------------------------------------------------

#pragma hdrstop

#include "Protocol_211.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

void TProtocol_211::setProtocol(void)
{
   protocol_type = PROTOCOL_TYPE_IND3;
}

//-----------------------------Обработка Escape байт---------------------------------

int TProtocol_211::EscapeBytesEncode(unsigned char* buf, int* len, int frame)
{
		unsigned char tmpbuf[PACKETBUF_LEN];
        memset(tmpbuf,0,PACKETBUF_LEN);
        int idx=0;
        int idxstart=0;

//Если отдали на кодирование не произвольный фрагмента а корректный фрейм нулевой байт всегда 0x7E
        if (frame)
        {
                tmpbuf[0]=buf[0];
                idx++;
                idxstart++;
        }

        for (int i=idxstart; i<(*len); i++)
        {
//Если отдали на кодирование не произвольный фрагмента а корректный фрейм последний байт всегда 0x7E
//Дошли до конца исходногопакета - пишемконец пакетаи выходим

              if (frame)
              {
                 if (i==(*len-1))
                 {
                    tmpbuf[idx]=0x7E; idx++;
                    break;
                 }

              }

              if ((buf[i]!=PACKET_START)&&(buf[i]!=ESCAPE_BYTE))
              {
                    tmpbuf[idx]=buf[i];      idx++;
              }
              else
              {

                    tmpbuf[idx]=ESCAPE_BYTE; idx++;

                    if (buf[i]==PACKET_START)
                    {
                        tmpbuf[idx]=CODE7E_BYTE; idx++;
                    }

                    if (buf[i]==ESCAPE_BYTE)
                    {
                        tmpbuf[idx]=CODE7D_BYTE; idx++;
                    }
              }

        }

        (*len)=idx;
        memcpy(buf,tmpbuf,idx);

        return 0;
 }


 int TProtocol_211::EscapeBytesDecode(unsigned char* buf, int* len, int frame)
 {
        unsigned char tmpbuf[PACKETBUF_LEN];
        memset(tmpbuf,0,PACKETBUF_LEN);
        int idx=0;
        int idxstart=0;
        int sleep=0;

//Если отдали на кодирование не произвольный фрагмент а корректный фрейм нулевой байт всегда 0xE7
        if (frame)
        {
                tmpbuf[0]=buf[0];
                idx++;
                idxstart++;
        }

        for (int i=1; i<(*len); i++)
        {
//Если отдали на кодирование не произвольный фрагмент а корректный фрейм последний байт всегда 0xE7
//Дошли до конца исходного пакета - пишем конец пакета и выходим

              if (frame)
              {
                 if (i==(*len-1))
                 {
                    tmpbuf[idx]=0x7E; idx++;
                    break;
                 }

              }

              if (sleep)
              {
                    sleep=0;
                    continue;
              }

              if (buf[i]!=ESCAPE_BYTE)
              {
                    tmpbuf[idx]=buf[i];
              }
              else
              {

                    if (buf[i+1]==CODE7E_BYTE)
                    {
                        tmpbuf[idx]=0x7E;
                    }

                    if (buf[i+1]==CODE7D_BYTE)
                    {
                        tmpbuf[idx]=0x7D;
                    }

                    sleep=1;

              }

               idx++;

        }

        (*len)=idx;
        memcpy(buf,tmpbuf,idx);

        return 0;
 }

//-------------------------------------------------------------------------------

//Основной протокол пакета запроса
void TProtocol_211::RequestMainMeterPacket(unsigned char addr, main_packet_211_id packet)
{
//Инициализация
	 clear_tx(); unsigned char chsum=0;
//Начало пакета
	  buftx[tx_idx] = PACKET_START; tx_idx++;
//Тип протокола
	  buftx[tx_idx] = MAIN_PR_211;           chsum=chsum^buftx[tx_idx]; tx_idx++;
//Тип пакета
	  buftx[tx_idx] = packet;                chsum=chsum^buftx[tx_idx]; tx_idx++;
//Адркс измерителя
	  buftx[tx_idx] = addr;                  chsum=chsum^buftx[tx_idx]; tx_idx++;
//Контрольная сумма
	  buftx[tx_idx] = chsum;                                            tx_idx++;
//Конец пакета
	  buftx[tx_idx] = PACKET_END;                                       tx_idx++;

//Кодируем ESCAP Eпоследовательности
	 this->EscapeBytesEncode(buftx, &tx_idx, 1);

}

/*
	заполняет запрос на углы x y
	запрос сформирован в buftx
	длина пакета сформирована в tx_idx

*/
int TProtocol_211::request_curr_XY(BYTE addr)
{
	RequestMainMeterPacket(addr, MEAS_VAL);

	return 0;
}

int TProtocol_211::accept_response_curr_XY(BYTE addr)
{

     return 0;
}
